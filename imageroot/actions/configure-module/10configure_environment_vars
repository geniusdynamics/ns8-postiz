#!/usr/bin/env python3

#
# Copyright (C) 2022 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-3.0-or-later
#

import json
import sys
import agent

# Try to parse the stdin as JSON.
# If parsing fails, output everything to stderr
data = json.load(sys.stdin)

#This is specific to you module, so you need to change it accordingly.
#agent.dump_env()
 
spotlight = { 
} 
agent.write_envfile("spotlight.env", spotlight) 
TEMPORAL_CORS_ORIGINS = data.get("TEMPORAL_CORS_ORIGINS", "http://127.0.0.1:3000") 
TEMPORAL_ADDRESS = data.get("TEMPORAL_ADDRESS", "temporal:7233") 
 
temporal-ui = { 
 "TEMPORAL_CORS_ORIGINS" : TEMPORAL_CORS_ORIGINS ,
 "TEMPORAL_ADDRESS" : TEMPORAL_ADDRESS ,
} 
agent.write_envfile("temporal-ui.env", temporal-ui) 
 
postiz-redis = { 
} 
agent.write_envfile("postiz-redis.env", postiz-redis) 
cluster.routing.allocation.disk.watermark.flood_stage = data.get("cluster.routing.allocation.disk.watermark.flood_stage", "128mb") 
discovery.type = data.get("discovery.type", "single-node") 
ES_JAVA_OPTS = data.get("ES_JAVA_OPTS", "-Xms256m -Xmx256m") 
xpack.security.enabled = data.get("xpack.security.enabled", "false") 
cluster.routing.allocation.disk.threshold_enabled = data.get("cluster.routing.allocation.disk.threshold_enabled", "true") 
cluster.routing.allocation.disk.watermark.low = data.get("cluster.routing.allocation.disk.watermark.low", "512mb") 
cluster.routing.allocation.disk.watermark.high = data.get("cluster.routing.allocation.disk.watermark.high", "256mb") 
 
temporal-elasticsearch = { 
 "cluster.routing.allocation.disk.watermark.flood_stage" : cluster.routing.allocation.disk.watermark.flood_stage ,
 "discovery.type" : discovery.type ,
 "ES_JAVA_OPTS" : ES_JAVA_OPTS ,
 "xpack.security.enabled" : xpack.security.enabled ,
 "cluster.routing.allocation.disk.threshold_enabled" : cluster.routing.allocation.disk.threshold_enabled ,
 "cluster.routing.allocation.disk.watermark.low" : cluster.routing.allocation.disk.watermark.low ,
 "cluster.routing.allocation.disk.watermark.high" : cluster.routing.allocation.disk.watermark.high ,
} 
agent.write_envfile("temporal-elasticsearch.env", temporal-elasticsearch) 
